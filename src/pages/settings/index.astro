---
import SettingsLayout from "@layouts/SettingsLayout.astro";
import Dropdown from "@components/ui/Dropdown.astro";
import Input from "@components/ui/Input.astro";
import Button from "@components/ui/Button.astro";
import { SearchEngines, type DropdownOptions } from "@utils/types";
const SearchEngineOptions: DropdownOptions[] = [];
Object.keys(SearchEngines).forEach((k) =>
    SearchEngineOptions.push({ name: k, value: SearchEngines[k] })
);
---
<SettingsLayout active="proxy" title="Proxy"> 
    <div class="w-full flex-grow">
        <div>
            <p> Proxy Switcher </p>
            <Dropdown id="pSwitcher" options={
                [
                    { name: 'Ultraviolet', value: 'uv', default: true },
                    { name: 'Scramjet', value: 'sj' }
                ]
            } />
        </div>
        <div class="mt-2">
            <p> Routing Mode </p>
            <Dropdown id="rSwitcher" options={
                [
                    { name: 'Wisp Server', value: 'wisp', default: true },
                    { name: 'Bare Server', value: 'bare' }
                ]
            } />
        </div>
        <div class="mt-2" id="transportSection">
            <p> Transport </p>
            <Dropdown id="tSwitcher" options={
                [
                    { name: 'Libcurl', value: 'libcurl', default: true },
                    { name: 'Epoxy', value: 'epoxy' }
                ]
            } />
        </div>
        <div class="mt-2">
            <p> Search Engine </p>
            <Dropdown id="sSwitcher" options={SearchEngineOptions} />
        </div>
        <div class="mt-2">
            <p> Verification Type </p>
            <Dropdown id="vTypeSwitcher" options={
                [
                    { name: 'None', value: 'none', default: true },
                    { name: 'reCAPTCHA v3', value: 'recaptcha' },
                    { name: 'Cloudflare Turnstile', value: 'cloudflare' }
                ]
            } />
        </div>
        <div class="mt-2 w-80 hidden" id="verificationSection">
            <div>
                <p> Verification Site Key </p>
                <Input id="verificationSiteKey" placeholder="Enter your site key" />
            </div>
            <div class="mt-2 mb-2 hidden" id="verificationInfo">
                <p class="text-blue-500" id="verificationInfo-inner"> Status... </p>
            </div>
            <div class="mt-2 flex flex-row gap-4">
                <Button id="verificationSave" text="Save Verification" icon="lucide:save" />
                <Button id="verificationReset" text="Reset" icon="lucide:rotate-ccw" />
            </div>
        </div>
        <div class="mt-2 w-80" id="wispServerSection">
            <div>
                <p> Wisp Server </p>
                <Input id="wispServerSwitcher" placeholder="Wisp server URL (EX: wss://radiusproxy.app/wisp/" />
                <div class="mt-2 hidden" id="adBlocking">
                    <p> Ad Blocking </p>
                    <Dropdown id="adBlocking" options={
                        [
                            { name: 'Enabled', value: 'enabled', default: true },
                            { name: 'Disabled', value: 'disabled' }
                        ]
                    } />
                </div>
            </div>
            <div class="mt-2 mb-2 hidden" id="wispServerInfo">
                <p class="text-blue-500" id="wispServerInfo-inner"> Checking URL... </p>
            </div>
            <div class="mt-2 flex flex-row gap-4">
                <Button id="wispServerSave" text="Save Changes" icon="lucide:save" />
                <Button id="wispServerReset" text="Reset" icon="lucide:rotate-ccw" />
            </div>
        </div>
    </div>
</SettingsLayout>
<script>
    import { Settings } from "@utils/settings.ts";
    import { SW } from "@utils/proxy.ts";
    import { StoreManager } from "@utils/storage";
    import { SearchEngines } from "@utils/types";

    type Options = {
        settings: Settings,
        sw: SW,
        storageManager: StoreManager<"radius||settings">
    }

    const routingMode = async (opts: Options) => {
        const routingEl = document.getElementById("dropdownBox-rSwitcher") as HTMLSelectElement;
        const transportSection = document.getElementById("transportSection") as HTMLDivElement;
        const wispServerSection = document.getElementById("wispServerSection") as HTMLDivElement;
        
        routingEl.value = opts.storageManager.getVal("routingMode") || "wisp";
        
        const updateVisibility = (mode: string) => {
            if (mode === "bare") {
                transportSection.classList.add("hidden");
                wispServerSection.classList.add("hidden");
            } else {
                transportSection.classList.remove("hidden");
                wispServerSection.classList.remove("hidden");
            }
        };
        
        updateVisibility(routingEl.value);
        
        routingEl.addEventListener("change", async () => {
            await opts.sw.routingMode(routingEl.value as "wisp" | "bare", true);
            updateVisibility(routingEl.value);
        });
    }

    const transport = async (opts: Options) => {
        const transportEl = document.getElementById("dropdownBox-tSwitcher") as HTMLSelectElement;
        transportEl.value = opts.storageManager.getVal("transport") || "libcurl"; 
        transportEl.addEventListener("change", async () => {
            opts.sw.setTransport(transportEl.value as "epoxy" | "libcurl");
        });
    }

    const proxy = async (opts: Options) => {
        const proxyEl = document.getElementById("dropdownBox-pSwitcher") as HTMLSelectElement;
        proxyEl.value = opts.storageManager.getVal("proxy") || "uv";
        proxyEl.addEventListener("change", async () => {
            opts.settings.proxy(proxyEl.value as "uv" | "sj");
        });
    }

    const searchEngine = async (opts: Options) => {
        const seEl = document.getElementById("dropdownBox-sSwitcher") as HTMLSelectElement;
        seEl.value = opts.storageManager.getVal("searchEngine") || SearchEngines.DuckDuckGo;
        seEl.addEventListener("change", async () => {
            opts.settings.searchEngine(seEl.value);
        });
    } 

    const wispServer = async (opts: Options) => {
        const wispServerSwitcher = document.getElementById("wispServerSwitcher") as HTMLInputElement;
        const wispServerInfo = document.getElementById("wispServerInfo") as HTMLElement;
        const wispServerInfoInner = document.getElementById("wispServerInfo-inner") as HTMLParagraphElement;
        const wispServerSave = document.getElementById("wispServerSave") as HTMLButtonElement;
        const wispServerReset = document.getElementById("wispServerReset") as HTMLButtonElement;
        const adBlocking = document.getElementById("adBlocking") as HTMLDivElement;

        wispServerSwitcher.value = opts.storageManager.getVal("wispServer");
        const resetVal = `${(location.protocol === "https:" ? "wss://" : "ws://")}${location.host}/wisp/` 
        const reset = (hide: boolean = true) => {
            if (hide) wispServerInfo.classList.add("hidden");
            wispServerInfoInner.innerText = "Checking URL..."
            wispServerInfoInner.classList.remove("text-red-500");
            wispServerInfoInner.classList.remove("text-green-500");
        };

        const adBlockingFunc = () => {
            const adBlockingDropdown = document.getElementById("dropdownBox-adBlocking") as HTMLSelectElement;
            adBlockingDropdown.addEventListener("change", () => {
                opts.settings.adBlock(adBlockingDropdown.value === "enabled" ? true : false);
            });

            adBlockingDropdown.value = opts.storageManager.getVal("adBlock") === "true" ? "enabled" : "disabled";

            if (wispServerSwitcher.value === resetVal) {
                adBlocking.classList.remove("hidden");
                opts.settings.adBlock(true);
                adBlockingDropdown.value = "enabled";
            }
            else {
                adBlocking.classList.add("hidden");
                opts.settings.adBlock(false);
            }
        }
        adBlockingFunc();

        wispServerSave.addEventListener("click", async () => {
            const server = wispServerSwitcher.value;
            wispServerInfo.classList.remove("hidden"); 

            if (!server.match(/^wss?:\/\/.*/)) {
                reset(false);
                wispServerInfoInner.innerText = "Invalid URL! \nURL's MUST start with wss:// or ws://";
                wispServerInfoInner.classList.add("text-red-500");
            }
            else {
                //TODO: we need to actually check if the wisp server exists. But for now, this will work
                reset(false);
                wispServerInfoInner.innerText = "Wisp Server Set!";
                wispServerInfoInner.classList.add("text-green-500");
                //adBlocking.classList.contains("hidden") ? "" : adBlocking.classList.add("hidden");
                await opts.sw.wispServer(wispServerSwitcher.value, true);
                adBlockingFunc();
            }

            // We reset this after 4 seconds (any errors OR success)
            setTimeout(reset, 4000);
        });

        wispServerReset.addEventListener("click", async () => {
            wispServerInfo.classList.remove("hidden");
            wispServerInfoInner.innerText = "Wisp Server Reset!";
            wispServerInfoInner.classList.add("text-green-500");
            await opts.sw.wispServer(resetVal, true);
            wispServerSwitcher.value = opts.storageManager.getVal("wispServer");
            setTimeout(reset, 4000);
            adBlockingFunc();
        });
    }

    const verification = async (opts: Options) => {
        const vTypeEl = document.getElementById("dropdownBox-vTypeSwitcher") as HTMLSelectElement;
        const verificationSection = document.getElementById("verificationSection") as HTMLDivElement;
        const verificationSiteKey = document.getElementById("verificationSiteKey") as HTMLInputElement;
        const verificationInfo = document.getElementById("verificationInfo") as HTMLElement;
        const verificationInfoInner = document.getElementById("verificationInfo-inner") as HTMLParagraphElement;
        const verificationSave = document.getElementById("verificationSave") as HTMLButtonElement;
        const verificationReset = document.getElementById("verificationReset") as HTMLButtonElement;

        const currentType = opts.storageManager.getVal("verificationType") || "none";
        vTypeEl.value = currentType;
        
        if (currentType !== "none") {
            verificationSection.classList.remove("hidden");
            verificationSiteKey.value = opts.storageManager.getVal("verificationSiteKey") || "";
        }

        const reset = (hide: boolean = true) => {
            if (hide) verificationInfo.classList.add("hidden");
            verificationInfoInner.innerText = "Status...";
            verificationInfoInner.classList.remove("text-red-500");
            verificationInfoInner.classList.remove("text-green-500");
            verificationInfoInner.classList.add("text-blue-500");
        };

        vTypeEl.addEventListener("change", () => {
            const selectedType = vTypeEl.value;
            if (selectedType === "none") {
                verificationSection.classList.add("hidden");
                opts.sw.setVerificationConfig({ type: "none" });
            } else {
                verificationSection.classList.remove("hidden");
            }
        });

        verificationSave.addEventListener("click", async () => {
            const siteKey = verificationSiteKey.value.trim();
            const type = vTypeEl.value as "none" | "recaptcha" | "cloudflare";

            verificationInfo.classList.remove("hidden");

            if (type !== "none" && !siteKey) {
                reset(false);
                verificationInfoInner.innerText = "Site key is required for verification!";
                verificationInfoInner.classList.remove("text-blue-500");
                verificationInfoInner.classList.add("text-red-500");
                setTimeout(reset, 4000);
                return;
            }

            opts.sw.setVerificationConfig({
                type: type,
                siteKey: siteKey || undefined
            });

            reset(false);
            verificationInfoInner.innerText = "Verification settings saved!";
            verificationInfoInner.classList.remove("text-blue-500");
            verificationInfoInner.classList.add("text-green-500");

            // Refresh the transport with new verification settings
            await opts.sw.setTransport();

            setTimeout(reset, 4000);
        });

        verificationReset.addEventListener("click", () => {
            vTypeEl.value = "none";
            verificationSiteKey.value = "";
            verificationSection.classList.add("hidden");
            opts.sw.setVerificationConfig({ type: "none" });
            
            verificationInfo.classList.remove("hidden");
            reset(false);
            verificationInfoInner.innerText = "Verification reset!";
            verificationInfoInner.classList.remove("text-blue-500");
            verificationInfoInner.classList.add("text-green-500");
            setTimeout(reset, 4000);
        });
    }

    document.addEventListener("astro:page-load", async () => {
        try {
            const settings = await Settings.getInstance();
            const sw = SW.getInstance().next().value!; 
            const storageManager = new StoreManager<"radius||settings">("radius||settings");
            await routingMode({settings, sw, storageManager});
            await transport({settings, sw, storageManager});
            await proxy({settings, sw, storageManager});
            await searchEngine({settings, sw, storageManager});
            await verification({settings, sw, storageManager});
            await wispServer({settings, sw, storageManager});
        } catch (err) {
            //console.log(err);
        }
    });
</script>
