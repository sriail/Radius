---
import Layout from "@layouts/Layout.astro";
import { Icon } from "astro-icon/components";

import splash from "@assets/splash.json";

const genSplash = (): String => {
    const idx = Math.floor(Math.random() * splash.length);
    return splash[idx].splash;
};

const randomSplash = genSplash();

const link = Astro.url.searchParams.get("redir");
---

<Layout>
    <div class="h-full flex items-center justify-center font-inter">
        <div class="flex flex-col items-center gap-6">
            <div class="flex items-center gap-2">
                <Icon name="lucide:radius" class="h-16 w-16 rotate-180 text-(--foreground)" />
                <h1 class="text-6xl font-semibold">Radius</h1>
            </div>
            <div class="flex flex-row items-center gap-2 w-4/5 md:w-[26rem] border border-(--input) rounded-lg h-12 p-2">
                <Icon name="lucide:search" />
                <input id="input" type="text" name="Search" class="text-md md:text-sm focus-visible:outline-none w-full h-full placeholder:text-(--muted-foreground)" id="search" placeholder="Search the web">
            </div>
            <p class="text-sm text-center sm:text-base whitespace-nowrap"> { randomSplash } </p>
            {/** <div class="w-full flex flex-row gap-2">
                <div class="rounded-md border-2">
                    t
                </div>
            </div> */}
        </div>
        <iframe id="iframe" class="fixed h-[calc(100%-3.5rem)] mt-14 w-full hidden bg-(--background)" />
        <link-element data-link={link} />
    </div>
</Layout>

<!-- Inline script to intercept window.open globally and set up message handling -->
<script is:inline>
    // This runs before any modules load
    (function() {
        // Store reference to original window.open
        const originalWindowOpen = window.open;
        
        // Track if we're currently opening a window from our code
        let isInternalOpen = false;
        
        // Override window.open globally
        window.open = function(url, target, features) {
            // If this is an internal call, allow it
            if (isInternalOpen) {
                return originalWindowOpen.call(this, url, target, features);
            }
            
            // Otherwise, navigate the iframe instead
            const iframe = document.getElementById('iframe');
            if (iframe && url) {
                // Signal to navigate the iframe
                window.postMessage({
                    type: 'navigate-iframe-internal',
                    url: url.toString()
                }, '*');
                return null;
            }
            
            // Fallback to original behavior
            return originalWindowOpen.call(this, url, target, features);
        };
        
        // Make the flag available globally for internal use
        window.__setInternalOpen = function(value) {
            isInternalOpen = value;
        };
    })();
</script>

<script>
    import { SW } from "@utils/proxy.ts";
    import { Settings } from "@utils/settings.ts";
    import { BareClient } from "@mercuryworkshop/bare-mux"; 

    const init = async () => {
        const input = document.getElementById("input") as HTMLInputElement;
        const iframe = document.getElementById("iframe") as HTMLIFrameElement;
        const iframeWin = iframe.contentWindow;
        const bhl = document.getElementById("bhl") as HTMLDivElement;
        const phl = document.getElementById("phl") as HTMLDivElement;
        const phlImage = document.getElementById("phlImage") as HTMLImageElement;
        const phlTitle = document.getElementById("phlTitle") as HTMLDivElement;
        const proxyLeft = document.getElementById("pal") as HTMLButtonElement;
        const proxyRight = document.getElementById("par") as HTMLButtonElement;
        const proxyReload = document.getElementById("prl") as HTMLButtonElement;
        const proxyShortcut = {
            button: document.getElementById("psc") as HTMLButtonElement,
            noShortcut: document.getElementById("noShortcut") as HTMLElement,
            shortcut: document.getElementById("shortcut") as HTMLElement
        }
        const client = new BareClient();
        
        // Get SW instance and wait for it to be ready
        const sw = SW.getInstance().next().value!;
        await sw.ready();
        
        // Listen for messages from iframe to navigate it
        window.addEventListener('message', (event) => {
            console.log('Received message:', event.data);
            if (event.data && event.data.type === 'navigate-iframe' && event.data.url) {
                // Navigate the iframe to the requested URL
                console.log('Navigating iframe to:', event.data.url);
                iframe.src = sw.encodeURL(event.data.url);
            }
            // Handle internal navigation requests (from our global window.open override)
            if (event.data && event.data.type === 'navigate-iframe-internal' && event.data.url) {
                // Navigate the iframe to the requested URL
                console.log('Navigating iframe (internal) to:', event.data.url);
                iframe.classList.remove("hidden");
                iframe.src = sw.encodeURL(event.data.url);
            }
        });
        
        input.addEventListener("keypress", async (event: any) => {
            if (event.key === "Enter") {
                // Handle "about:" URLs
                const inputValue = input.value.trim();
                const aboutMatch = inputValue.match(/^about:(.+)$/);
                if (aboutMatch) {
                    const target = aboutMatch[1];
                    switch (target) {
                        case 'settings':
                            window.location.href = '/settings';
                            return;
                        case 'home':
                            window.location.href = '/';
                            return;
                        case '404':
                            window.location.href = '/404';
                            return;
                    }
                }

                const settings = await Settings.getInstance();
                iframe.classList.remove("hidden");
                iframe.src = sw.encodeURL(input.value); 
                buttons();
            }
        });

        const getURL = async (): Promise<string> => {
            if (iframeWin!.__uv) {
                return iframeWin!.__uv.location.href
            }
            else if (iframeWin!.$scramjet?.config?.prefix) {
                return iframeWin!.location.href
                    .replace(iframeWin!.location.origin, '')
                    .replace(iframeWin!.$scramjet.config.prefix, '')
            }
            else {
                // Fallback if neither proxy is available
                return iframeWin!.location.href;
            }
        }

        const buttons = () => {
            proxyLeft.addEventListener("click", () => {
                iframeWin!.history.back();
            });
            proxyRight.addEventListener("click", () => {
                iframeWin!.history.forward();
            });
            proxyReload.addEventListener("click", () => {
                iframeWin!.location.reload();
            });
            /** proxyShortcut.button.addEventListener("click", () => {
                console.log("yet to be implemented");
            }); */
        }

        iframe.addEventListener("load", async () => {
            phlTitle.innerHTML = iframeWin!.document.title;
            const pageURL = await getURL();
            const data = await client.fetch(`https://www.google.com/s2/favicons?domain=${pageURL}&sz=64`);
            const dataRes = await data.blob();
            const object = URL.createObjectURL(dataRes);
            phlImage.src = object;
            bhl.classList.add("hidden");
            phl.classList.remove("hidden");
            
            // Inject the interception script into the iframe
            try {
                if (iframeWin && iframeWin.document) {
                    console.log("Injecting interception script into iframe");
                    const script = iframeWin.document.createElement('script');
                    script.textContent = `
                        (function() {
                            'use strict';
                            console.log('[Iframe Intercept] Script loaded');
                            const originalWindowOpen = window.open;
                            window.open = function(url, target, features) {
                                console.log('[Iframe Intercept] window.open called with:', url, target);
                                if (url && window.parent !== window) {
                                    try {
                                        console.log('[Iframe Intercept] Sending navigate message to parent');
                                        window.parent.postMessage({
                                            type: 'navigate-iframe',
                                            url: url.toString()
                                        }, '*');
                                        return null;
                                    } catch (e) {
                                        console.error('[Iframe Intercept] Failed to communicate with parent:', e);
                                    }
                                }
                                return originalWindowOpen.call(this, url, target, features);
                            };
                            
                            document.addEventListener('click', function(e) {
                                const anchor = e.target.closest('a');
                                if (anchor && anchor.href) {
                                    const target = anchor.getAttribute('target');
                                    console.log('[Iframe Intercept] Link clicked:', anchor.href, 'target:', target);
                                    if (target === '_blank' || target === '_new' || target === '_parent' || target === '_top') {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        console.log('[Iframe Intercept] Intercepting link, calling window.open');
                                        window.open(anchor.href);
                                    }
                                }
                            }, true);
                            
                            // Set base target to _self to prevent new windows by default
                            const setBaseTarget = () => {
                                const baseTag = document.querySelector('base');
                                if (!baseTag) {
                                    const newBase = document.createElement('base');
                                    newBase.target = '_self';
                                    if (document.head) {
                                        document.head.insertBefore(newBase, document.head.firstChild);
                                    }
                                    console.log('[Iframe Intercept] Created base tag with target="_self"');
                                } else if (!baseTag.hasAttribute('target')) {
                                    baseTag.target = '_self';
                                    console.log('[Iframe Intercept] Set existing base tag target to "_self"');
                                }
                            };
                            if (document.readyState === 'loading') {
                                document.addEventListener('DOMContentLoaded', setBaseTarget);
                            } else {
                                setBaseTarget();
                            }
                        })();
                    `;
                    iframeWin.document.head.appendChild(script);
                    console.log("Interception script injected successfully");
                }
            } catch (e) {
                // Cross-origin restrictions may prevent this during initial load
                // This is expected when loading proxied content
                console.log("Could not inject script directly:", e);
            }
        }); 
    }

    class CustomComponent extends HTMLElement {
        connectedCallback() {
            const link = this.dataset.link;
            const input = document.getElementById("input") as HTMLInputElement;
            if (link) {
                return (async () => {
                    await init();
                    try {
                        input.value = atob(link);
                    } catch (_) {
                        input.value = link;
                    }
                    input.dispatchEvent(new KeyboardEvent("keypress", { key: "Enter", code: "Enter" }));
                    history.pushState({}, "", "/");
                })();
            }
        }
    }
    
    customElements.define('link-element', CustomComponent);
    document.addEventListener("astro:page-load", async () => {
        try {
            await init();
        }
        catch (_) {}
    });
</script>
