---
import Layout from "@layouts/Layout.astro";
import { Icon } from "astro-icon/components";

import splash from "@assets/splash.json";

const genSplash = (): String => {
    const idx = Math.floor(Math.random() * splash.length);
    return splash[idx].splash;
};

const randomSplash = genSplash();

const link = Astro.url.searchParams.get("redir");
---

<Layout>
    <div class="h-full flex items-center justify-center font-inter">
        <div class="flex flex-col items-center gap-6">
            <div class="flex items-center gap-2">
                <Icon name="lucide:radius" class="h-16 w-16 rotate-180 text-(--foreground)" />
                <h1 class="text-6xl font-semibold">Radius</h1>
            </div>
            <div class="flex flex-row items-center gap-2 w-4/5 md:w-[26rem] border border-(--input) rounded-lg h-12 p-2">
                <Icon name="lucide:search" />
                <input id="input" type="text" name="Search" class="text-md md:text-sm focus-visible:outline-none w-full h-full placeholder:text-(--muted-foreground)" id="search" placeholder="Search the web">
            </div>
            <p class="text-sm text-center sm:text-base whitespace-nowrap"> { randomSplash } </p>
            {/** <div class="w-full flex flex-row gap-2">
                <div class="rounded-md border-2">
                    t
                </div>
            </div> */}
        </div>
        <iframe id="iframe" class="fixed h-[calc(100%-3.5rem)] mt-14 w-full hidden bg-(--background)" />
        <link-element data-link={link} />
    </div>
</Layout>
<script>
    import { SW } from "@utils/proxy.ts";
    import { BareClient } from "@mercuryworkshop/bare-mux";
    import { setupIframeInterceptor } from "@utils/iframe-interceptor.ts";

    const init = async () => {
        const input = document.getElementById("input") as HTMLInputElement;
        const iframe = document.getElementById("iframe") as HTMLIFrameElement;
        const bhl = document.getElementById("bhl") as HTMLDivElement;
        const phl = document.getElementById("phl") as HTMLDivElement;
        const phlImage = document.getElementById("phlImage") as HTMLImageElement;
        const phlTitle = document.getElementById("phlTitle") as HTMLDivElement;
        const proxyLeft = document.getElementById("pal") as HTMLButtonElement;
        const proxyRight = document.getElementById("par") as HTMLButtonElement;
        const proxyReload = document.getElementById("prl") as HTMLButtonElement;
        const client = new BareClient();
        
        // Get SW instance and wait for it to be ready
        const sw = SW.getInstance().next().value!;
        await sw.ready();
        
        // Setup iframe interceptor to prevent new tabs/windows
        setupIframeInterceptor(iframe, (url: string) => sw.encodeURL(url));

        // Helper function to get the current iframe window safely
        const getIframeWindow = (): Window | null => {
            try {
                return iframe.contentWindow;
            } catch {
                return null;
            }
        };

        const getURL = async (): Promise<string> => {
            const iframeWin = getIframeWindow();
            if (!iframeWin) return "";
            
            try {
                if (iframeWin.__uv) {
                    return iframeWin.__uv.location.href;
                }
                else if (iframeWin.$scramjet?.config?.prefix) {
                    return iframeWin.location.href
                        .replace(iframeWin.location.origin, '')
                        .replace(iframeWin.$scramjet.config.prefix, '');
                }
                else {
                    // Fallback if neither proxy is available
                    return iframeWin.location.href;
                }
            } catch {
                // Cross-origin access error - try to extract from iframe src
                return "";
            }
        };

        // Setup navigation buttons once (not on every search)
        // Use event delegation pattern to avoid duplicate listeners
        const setupNavigationButtons = () => {
            // Remove old listeners by cloning elements
            const newProxyLeft = proxyLeft.cloneNode(true) as HTMLButtonElement;
            const newProxyRight = proxyRight.cloneNode(true) as HTMLButtonElement;
            const newProxyReload = proxyReload.cloneNode(true) as HTMLButtonElement;
            
            proxyLeft.parentNode?.replaceChild(newProxyLeft, proxyLeft);
            proxyRight.parentNode?.replaceChild(newProxyRight, proxyRight);
            proxyReload.parentNode?.replaceChild(newProxyReload, proxyReload);

            // Add navigation event listeners
            newProxyLeft.addEventListener("click", () => {
                const iframeWin = getIframeWindow();
                if (iframeWin) {
                    try {
                        iframeWin.history.back();
                    } catch {
                        // Fallback: try using window.history if iframe is cross-origin
                        console.log("Navigation back failed - iframe may be cross-origin");
                    }
                }
            });

            newProxyRight.addEventListener("click", () => {
                const iframeWin = getIframeWindow();
                if (iframeWin) {
                    try {
                        iframeWin.history.forward();
                    } catch {
                        console.log("Navigation forward failed - iframe may be cross-origin");
                    }
                }
            });

            newProxyReload.addEventListener("click", () => {
                const iframeWin = getIframeWindow();
                if (iframeWin) {
                    try {
                        iframeWin.location.reload();
                    } catch {
                        // Fallback: reload iframe by resetting src
                        const currentSrc = iframe.src;
                        iframe.src = "";
                        iframe.src = currentSrc;
                    }
                }
            });
        };

        // Setup navigation buttons immediately
        setupNavigationButtons();
        
        input.addEventListener("keypress", async (event: any) => {
            if (event.key === "Enter") {
                // Handle "about:" URLs
                const inputValue = input.value.trim();
                const aboutMatch = inputValue.match(/^about:(.+)$/);
                if (aboutMatch) {
                    const target = aboutMatch[1];
                    switch (target) {
                        case 'settings':
                            window.location.href = '/settings';
                            return;
                        case 'home':
                            window.location.href = '/';
                            return;
                        case '404':
                            window.location.href = '/404';
                            return;
                    }
                }

                iframe.classList.remove("hidden");
                iframe.src = sw.encodeURL(input.value); 
            }
        });

        iframe.addEventListener("load", async () => {
            const iframeWin = getIframeWindow();
            if (!iframeWin) return;
            
            try {
                phlTitle.innerHTML = iframeWin.document.title || "Loading...";
            } catch {
                phlTitle.innerHTML = "Loading...";
            }
            
            const pageURL = await getURL();
            if (pageURL) {
                try {
                    const data = await client.fetch(`https://www.google.com/s2/favicons?domain=${pageURL}&sz=64`);
                    const dataRes = await data.blob();
                    const object = URL.createObjectURL(dataRes);
                    phlImage.src = object;
                } catch {
                    // Favicon fetch failed, use default
                }
            }
            bhl.classList.add("hidden");
            phl.classList.remove("hidden");
        }); 
    }

    class CustomComponent extends HTMLElement {
        connectedCallback() {
            const link = this.dataset.link;
            const input = document.getElementById("input") as HTMLInputElement;
            if (link) {
                return (async () => {
                    await init();
                    try {
                        // Decode base64 to UTF-8 string using standard pattern
                        input.value = decodeURIComponent(escape(atob(link)));
                    } catch (_) {
                        // Fallback: try decodeURIComponent for URL-encoded values
                        try {
                            input.value = decodeURIComponent(link);
                        } catch {
                            input.value = link;
                        }
                    }
                    input.dispatchEvent(new KeyboardEvent("keypress", { key: "Enter", code: "Enter" }));
                    history.pushState({}, "", "/");
                })();
            }
        }
    }
    
    customElements.define('link-element', CustomComponent);
    document.addEventListener("astro:page-load", async () => {
        try {
            await init();
        }
        catch (_) {}
    });
</script>
